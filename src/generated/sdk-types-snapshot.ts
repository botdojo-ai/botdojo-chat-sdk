/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * 
 * This file is generated by packages/sdk-types/scripts/generate-opensource-snapshots.js
 * It contains a snapshot of @botdojo/sdk-types exports needed by @botdojo/chat-sdk
 * 
 * To regenerate this file:
 *   1. cd packages/sdk-types
 *   2. pnpm sync-opensource
 * 
 * Generated: 2025-12-19T19:03:40.782Z
 */

/* eslint-disable */


// ============================================================================
// Supporting implementations from sdk-types
// ============================================================================

// From: tool-utils.ts
/**
 * Tool definition utilities for BotDojo
 * 
 * Provides a simplified API for defining tools and model contexts
 */




/**
 * JSON Schema definition for tool parameters
 */
export interface JSONSchema {
    type: 'object';
    properties: Record<string, any>;
    required?: string[];
    additionalProperties?: boolean;
}

/**
 * Zod-like schema interface (for type compatibility)
 */
export interface ZodSchema {
    _def?: any;
    parse: (data: any) => any;
}

/**
 * SDK Tool definition - extends base with parameter schema options
 * 
 * Display hints go in _meta with botdojo/ prefix:
 * - 'botdojo/display-name': string
 * - 'botdojo/hide-step': boolean
 * - 'botdojo/hide-step-details': boolean
 */
export interface SDKToolDefinition<TParams = any, TResult = any> {
    description: string;
    parameters?: JSONSchema | ZodSchema;
    execute: (params: TParams) => Promise<ToolExecutionResult<TResult>> | ToolExecutionResult<TResult>;
    /** Tool metadata - use for display hints and resource templates */
    _meta?: ToolMetadata;
}

/**
 * Tools record - a map of tool names to tool definitions
 */
export type ToolsRecord = Record<string, SDKToolDefinition>;

/**
 * Tool handler function
 */
export type ToolHandler<TParams = any, TResult = any> = (params: TParams) => Promise<ToolExecutionResult<TResult>> | ToolExecutionResult<TResult>;

/**
 * Create a tool definition
 * 
 * @example
 * ```typescript
 * const weatherTool = tool({
 *   description: 'Get the weather in a location',
 *   parameters: {
 *     type: 'object',
 *     properties: {
 *       location: { type: 'string', description: 'The location to get the weather for' }
 *     },
 *     required: ['location']
 *   },
 *   execute: async ({ location }) => ({
 *     location,
 *     temperature: 72
 *   })
 * });
 * ```
 */
export function tool<TParams = any, TResult = any>(
    definition: SDKToolDefinition<TParams, TResult>
): SDKToolDefinition<TParams, TResult> {
    return definition;
}

// ============================================================================
// ContentItem Helper Functions
// ============================================================================

/**
 * Create a text result content item
 * 
 * @example
 * ```typescript
 * return [textResult('Operation completed successfully')];
 * ```
 */
export function textResult(text: string): ContentItem {
    return { type: 'text', text };
}

/**
 * Create an image result content item
 * 
 * @example
 * ```typescript
 * return [imageResult(base64Data, 'image/png')];
 * ```
 */
export function imageResult(data: string, mimeType: string = 'image/png'): ContentItem {
    return { type: 'image', data, mimeType };
}

/**
 * Create a UI resource content item
 * 
 * @example
 * ```typescript
 * return [
 *   textResult('Product loaded'),
 *   uiResource('ui://product/123', {
 *     initialData: { product: productData },
 *     frameSize: { width: '100%', height: '500px' }
 *   })
 * ];
 * ```
 */
export function uiResource(
    uri: string, 
    options?: {
        initialData?: any;
        frameSize?: { width: string; height: string };
        mimeType?: 'text/uri-list' | 'text/html' | 'text/html+mcp' | 'text/html;profile=mcp-app' | 'application/vnd.botdojo.ui-remote-dom';
        /** Inline HTML content for MCP Apps */
        html?: string;
        /** Allowlist of URLs (url-list style) */
        urlList?: string[];
        /** Base URL applied to inline HTML for relative assets */
        baseUrl?: string;
        /** Force proxy/sandbox rendering even when a URL is present */
        prefersProxy?: boolean;
        /** Allow direct external URL rendering alongside inline HTML */
        allowExternal?: boolean;
        uiMeta?: {
            csp?: {
                connectDomains?: string[];
                resourceDomains?: string[];
                domain?: string;
                allowPopups?: boolean;
                allowForms?: boolean;
                allowSameOrigin?: boolean;
            };
            prefersBorder?: boolean;
            urlList?: string[];
            baseUrl?: string;
            prefersProxy?: boolean;
            allowExternal?: boolean;
        };
    }
): ContentItem {
    const resource: ResourceReference = {
        uri,
        mimeType: options?.mimeType || (uri.startsWith('ui://') ? MIME_TYPES.HTML_MCP_PROFILE : MIME_TYPES.URI_LIST),
    };

    if (options?.html) {
        resource.html = options.html;
    }
    if (options?.urlList) {
        resource.urlList = options.urlList;
    }
    if (options?.baseUrl) {
        resource.baseUrl = options.baseUrl;
    }
    if (options?.prefersProxy !== undefined) {
        resource.prefersProxy = options.prefersProxy;
    }
    if (options?.allowExternal !== undefined) {
        resource.allowExternal = options.allowExternal;
    }

    if (options?.initialData || options?.frameSize || options?.uiMeta) {
        resource.meta = {
            ui: {
                ...(options.uiMeta || {}),
                ...(options.frameSize ? { preferredFrameSize: options.frameSize } : {}),
                ...(options.initialData ? { initialRenderData: options.initialData } : {}),
            },
        } as any;
    }

    return { type: 'resource', resource };
}

/**
 * Create a ModelContext resource content item
 * The URI points to a resource handler that returns the ModelContext definition
 * 
 * @example
 * ```typescript
 * return [
 *   textResult('Cart actions available'),
 *   mcpResource('mcp://cart/actions')
 * ];
 * ```
 */
export function mcpResource(uri: string): ContentItem {
    return {
        type: 'resource',
        resource: {
            uri,
            mimeType: MIME_TYPES.MODEL_CONTEXT,
            text: uri  // URI points to resource handler
        }
    };
}

/**
 * Create a single citation content item
 * 
 * @example
 * ```typescript
 * return [
 *   textResult('Found information about the topic'),
 *   citation({ id: 'cite-1', source: 'Wikipedia', url: 'https://...' })
 * ];
 * ```
 */
export function citation(data: CitationData): ContentItem {
    return {
        type: 'resource',
        resource: {
            uri: `citation://${data.id}`,
            mimeType: MIME_TYPES.CITATION,
            text: JSON.stringify(data)
        }
    };
}

/**
 * Create multiple citations content item
 * 
 * @example
 * ```typescript
 * return [
 *   textResult('Found multiple sources'),
 *   citations([
 *     { id: 'cite-1', source: 'Wikipedia', url: 'https://...' },
 *     { id: 'cite-2', source: 'Documentation', url: 'https://...' }
 *   ])
 * ];
 * ```
 */
export function citations(data: CitationData[]): ContentItem {
    return {
        type: 'resource',
        resource: {
            uri: 'citations://batch',
            mimeType: MIME_TYPES.CITATIONS,
            text: JSON.stringify(data)
        }
    };
}

/**
 * Check if a schema is a Zod schema
 */
function isZodSchema(schema: any): schema is ZodSchema {
    return schema && typeof schema.parse === 'function';
}

/**
 * Note: Zod schema conversion is NOT supported in botdojo-sdk-types
 * to keep the package dependency-free.
 * 
 * Users should either:
 * 1. Use JSON Schema directly in their tool definitions
 * 2. Convert Zod schemas to JSON Schema in their own code using zod-to-json-schema
 * 
 * This function will throw an error if a Zod schema is passed.
 */
function zodToJsonSchema(zodSchema: ZodSchema): JSONSchema {
    throw new Error(
        'Zod schemas are not supported in botdojo-sdk-types to keep it dependency-free. ' +
        'Please use JSON Schema directly, or convert your Zod schema using zod-to-json-schema in your own code.'
    );
}

/**
 * Convert tool definitions to MCP model context format
 * 
 * @param contextName - Name of the model context
 * @param tools - Record of tool definitions
 * @param options - Optional configuration
 */
export function toolsToModelContext(
    contextName: string,
    tools: ToolsRecord,
    options?: {
        description?: string;
        toolPrefix?: string;
        /** Unique URI identifier for this model context */
        uri?: string;

    }
): ModelContext {
    const modelTools: BaseToolDefinition[] = [];

    // Convert each tool
    for (const [toolName, toolDef] of Object.entries(tools)) {
        // Convert schema if needed
        let jsonSchema: JSONSchema;
        
        if (toolDef.parameters) {
            if (isZodSchema(toolDef.parameters)) {
                jsonSchema = zodToJsonSchema(toolDef.parameters);
            } else {
                jsonSchema = toolDef.parameters as JSONSchema;
            }
        } else {
            // Default to empty object schema if no parameters defined
            jsonSchema = {
                type: 'object',
                properties: {},
                required: []
            };
        }

        // Create tool definition with execute function
        const baseTool: BaseToolDefinition = {
            name: toolName,
            description: toolDef.description,
            inputSchema: jsonSchema,
            execute: toolDef.execute
        };
        
        // Add _meta if display hints are provided
        if (toolDef._meta) {
            baseTool._meta = toolDef._meta;
        }
        
        modelTools.push(baseTool);
    }

    // Create model context
    const context: ModelContext = {
        name: contextName,
        description: options?.description || `Tools for ${contextName}`,
        toolPrefix: options?.toolPrefix,
        uri: options?.uri || `app://${contextName}`,
        tools: modelTools,
        prompts: []
    };

    return context;
}

/**
 * Helper to extract tool handlers from tool definitions
 * Handles both array and object formats
 */
export function extractToolHandlers(tools: BaseToolDefinition[] | Record<string, BaseToolDefinition>): Record<string, ToolHandler> {
    const handlers: Record<string, ToolHandler> = {};
    
    if (Array.isArray(tools)) {
        // Array format: tools with name field and optional execute
        for (const tool of tools) {
            if (tool.execute && tool.name) {
                handlers[tool.name] = tool.execute;
            }
        }
    } else {
        // Object format: key is tool name
        for (const [toolName, toolDef] of Object.entries(tools)) {
            if (toolDef.execute) {
                handlers[toolName] = toolDef.execute;
            }
        }
    }
    
    return handlers;
}

// Deprecated: actions-based ToolResponse mapping removed in favor of MCP Apps ContentItem[]
// import removed to prevent legacy usage

/**
 * Model Context definition options
 */
export interface ModelContextDefinition {
    name: string;
    uri?: string;
    description?: string;
    toolPrefix?: string;
    /**
     * Tools for this model context. Must return ContentItem[] (MCP Apps).
     * Legacy ToolResponse/actions are not supported.
     */
    tools?: ToolsRecord;
    resources?: ResourceDefinition[];
}

/**
 * Create a model context with tools and resources
 * 
 * @example
 * ```typescript
 * import { modelContext, tool, buildResourceProvider } from '@botdojo/chat-embed';
 * 
 * const myContext = modelContext({
 *   name: 'my_app',
 *   uri: 'myapp://mcp',
 *   description: 'My application tools',
 *   toolPrefix: 'app',
 *   tools: {
 *     setText: tool({
 *       description: 'Update text',
 *       parameters: {
 *         type: 'object',
 *         properties: {
 *           text: { type: 'string', description: 'The new text' }
 *         },
 *         required: ['text']
 *       },
 *       execute: async ({ text }) => {
 *         currentText = text;
 *         return toolResponse({
 *           result: { success: true },
 *           message: 'Text updated',
 *           actions: [actions.updateCanvas({ text })]
 *         });
 *       }
 *     }),
 *     getText: tool({
 *       description: 'Get current text',
 *       execute: async () => ({ text: currentText })
 *     })
 *   },
 *   resources: [
 *     {
 *       uri: 'myapp://help',
 *       mimeType: 'text/markdown',
 *       description: 'Help documentation',
 *       getContent: async () => '# Help\n\nMarkdown content'
 *     },
 *     {
 *       uriTemplate: 'myapp://users/{userId}',
 *       mimeType: 'application/json',
 *       description: 'User profile by ID',
 *       getContent: async ({ userId }) => {
 *         const user = await fetchUser(userId);
 *         return JSON.stringify(user);
 *       }
 *     }
 *   ]
 * });
 * 
 * // Use with BotDojoChat
 * <BotDojoChat apiKey="..." modelContext={myContext} />
 * ```
 */
export function modelContext(
    definition: ModelContextDefinition
): ModelContext {
    const { name, uri, description, toolPrefix, tools, resources } = definition;
    
    // Build base model context from tools (if provided)
    let context: ModelContext;
    if (tools && Object.keys(tools).length > 0) {
        context = toolsToModelContext(name, tools, {
            description,
            toolPrefix,
            uri
        });
    } else {
        // No tools - create minimal context
        context = {
            name,
            description: description || `Model context for ${name}`,
            toolPrefix,
            uri,
            tools: [],
            prompts: []
        };
    }
    
    return context;
}

// From: resource-utils.ts
/**
 * Resource utilities for building ResourceProviders
 * 
 * These utilities help users define static and dynamic resources
 * and automatically generate ResourceProvider implementations.
 */


/**
 * Resource content can be returned in multiple formats:
 * - Simple string (text, markdown, JSON, base64)
 * - URL reference { url: string } for external/large files
 * - Rich object with text, url, mcp, links, and metadata
 */
export type ResourceContentResult = 
    | string                          // Simple text/base64
    | { url: string }                 // External URL reference
    | ResourceContentObject;          // Rich object with multiple fields

/**
 * Rich resource content object
 */
export interface ResourceContentObject {
    /** Text content (markdown, JSON, base64, etc.) */
    text?: string;
    
    /** External URL reference (for hosted images, PDFs, etc.) */
    url?: string;
    
    /** Nested MCPs (for botdojo/mcp mimeType) */
    mcp?: ModelContext[];
    
    /** Related resource links */
    links?: Array<{
        uri: string;
        rel: string;
        description?: string;
    }>;
    
    /** Additional metadata */
    meta?: Record<string, any>;
}

/**
 * Static resource definition - fixed URI, no parameters
 */
export interface StaticResourceDefinition {
    /** Fixed URI for this resource */
    uri: string;
    
    /** MIME type (e.g., 'text/markdown', 'image/png', 'botdojo/mcp') */
    mimeType: string;
    
    /** Human-readable description */
    description?: string;
    
    /** Display label */
    label?: string;
    
    /** Get resource content */
    getContent: () => Promise<ResourceContentResult> | ResourceContentResult;
}

/**
 * Dynamic resource definition - templated URI with parameters
 */
export interface DynamicResourceDefinition {
    /** URI template following RFC 6570 (e.g., 'myapp://users/{userId}') */
    uriTemplate: string;
    
    /** MIME type */
    mimeType: string;
    
    /** Human-readable description */
    description?: string;
    
    /** Display label */
    label?: string;
    
    /** Get resource content with extracted parameters */
    getContent: (params: Record<string, any>) => Promise<ResourceContentResult> | ResourceContentResult;
}

/**
 * Resource definition - can be static or dynamic
 */
export type ResourceDefinition = StaticResourceDefinition | DynamicResourceDefinition;

/**
 * Check if a resource definition is dynamic (has uriTemplate)
 */
export function isDynamicResource(resource: ResourceDefinition): resource is DynamicResourceDefinition {
    return 'uriTemplate' in resource;
}

/**
 * Check if a URI matches a URI template pattern
 * @example matchesUriTemplate('myapp://users/123', 'myapp://users/{userId}') // true
 */
export function matchesUriTemplate(uri: string, template: string): boolean {
    const regexPattern = template.replace(/\{[^}]+\}/g, '([^/]+)');
    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(uri);
}

/**
 * Extract parameters from a URI based on a template
 * @example extractUriParams('myapp://users/123', 'myapp://users/{userId}') 
 * // Returns: { userId: '123' }
 */
export function extractUriParams(uri: string, template: string): Record<string, string> {
    const params: Record<string, string> = {};
    const templateParts = template.split('/');
    const uriParts = uri.split('/');
    
    for (let i = 0; i < templateParts.length; i++) {
        const templatePart = templateParts[i];
        if (templatePart.startsWith('{') && templatePart.endsWith('}')) {
            const paramName = templatePart.slice(1, -1);
            params[paramName] = uriParts[i];
        }
    }
    
    return params;
}

/**
 * Normalize resource content result to ResourceContent format
 */
function normalizeResourceContent(
    uri: string,
    mimeType: string,
    result: ResourceContentResult
): ResourceContent {
    // Simple string
    if (typeof result === 'string') {
        return {
            uri,
            mimeType,
            text: result
        };
    }
    
    // URL reference
    if ('url' in result && !('text' in result) && !('mcp' in result)) {
        return {
            uri,
            mimeType,
            text: JSON.stringify({ url: result.url })
        };
    }
    
    // Rich object
    return {
        uri,
        mimeType,
        ...result
    };
}

/**
 * Build a ResourceProvider from an array of resource definitions
 * 
 * @deprecated Use resources array directly in ModelContext instead
 * @param providerId Unique identifier for this provider
 * @param resources Array of static or dynamic resource definitions
 * @returns ResourceProvider (legacy format)
 * 
 * @example
 * ```typescript
 * // Instead of using buildResourceProvider, add resources directly:
 * const context = {
 *   name: 'myapp',
 *   resources: [
 *     // Static resource
 *     {
 *       uri: 'myapp://help',
 *       mimeType: 'text/markdown',
 *       description: 'Help documentation',
 *       getContent: async () => '# Help\n\nContent here'
 *     },
 *     // Dynamic resource
 *     {
 *       uriTemplate: 'myapp://users/{userId}',
 *       mimeType: 'application/json',
 *       description: 'User profile by ID',
 *       getContent: async ({ userId }) => {
 *         const user = await fetchUser(userId);
 *         return JSON.stringify(user);
 *       }
 *     }
 *   ]
 * };
 * ```
 */
export function buildResourceProvider(
    providerId: string,
    resources: ResourceDefinition[]
): ResourceProvider {
    // Build templates array
    const templates: ResourceTemplate[] = resources.map(resource => {
        if (isDynamicResource(resource)) {
            return {
                uriTemplate: resource.uriTemplate,
                name: resource.label || resource.uriTemplate,
                label: resource.label || resource.uriTemplate,
                description: resource.description,
                mimeType: resource.mimeType
            };
        } else {
            return {
                uriTemplate: resource.uri,
                name: resource.label || resource.uri,
                label: resource.label || resource.uri,
                description: resource.description,
                mimeType: resource.mimeType
            };
        }
    });

    // Build getResource handler
    const getResource = async (
        templateName: string,
        uri: string,
        params: any,
        onlyMetadata?: boolean
    ): Promise<ResourceContent> => {
        // Find matching resource definition
        for (const resource of resources) {
            const template = isDynamicResource(resource) ? resource.uriTemplate : resource.uri;
            
            if (matchesUriTemplate(uri, template)) {
                // Return metadata only if requested
                if (onlyMetadata) {
                    return {
                        uri,
                        mimeType: resource.mimeType,
                        meta: {
                            description: resource.description,
                            label: resource.label
                        }
                    };
                }

                // Get content
                let result: ResourceContentResult;
                if (isDynamicResource(resource)) {
                    // Extract params if not provided
                    const extractedParams = params || extractUriParams(uri, resource.uriTemplate);
                    result = await resource.getContent(extractedParams);
                } else {
                    result = await resource.getContent();
                }

                // Normalize and return
                return normalizeResourceContent(uri, resource.mimeType, result);
            }
        }

        throw new Error(`No resource definition found for URI: ${uri}`);
    };

    return {
        id: providerId,
        templates,
        getResource
    };
}

// From: type-translation.ts
/**
 * Type Translation Utilities
 * 
 * Translates consumer-friendly SDK types to backend API format.
 * This is the centralized place where SDK types are converted to backend format.
 * 
 * Used by:
 * - botdojo-sdk (BotDojoSDK client)
 * - botdojo-canvas-client (BotDojoConnector)
 * 
 * Note: Implementation is synced from botdojo-core via prebuild script.
 * This file wraps the synced implementation with proper SDK types.
 */


// Re-export types and implementation from synced snapshot
export type {
    BackendModelContext,
    BackendToolDef,
    BackendPromptDef,
    BackendResourceDef
} from './modelContextTranslation-snapshot';

// Import implementation from synced snapshot

/**
 * Translate SDK ModelContext to backend format
 * 
 * @param context - The SDK ModelContext from consumer
 * @returns Backend format ready to send via API/RPC (CanvasModelContext format)
 */
export function translateModelContextToBackend(
    context: ModelContext
): import('./modelContextTranslation-snapshot').BackendModelContext {
    return translateModelContextToBackendImpl(context);
}

/**
 * Translate tools (array or object) to backend CanvasModelContextTool format
 * 
 * SDK allows tools as either:
 * - Array: [{ name: "tool1", ... }, { name: "tool2", ... }]
 * - Object: { tool1: { description: "...", ... }, tool2: { ... } }
 * 
 * Backend always expects array format with explicit names.
 */
export function translateToolsToBackend(
    tools: ToolDefinition[] | Record<string, ToolDefinition>
): import('./modelContextTranslation-snapshot').BackendToolDef[] {
    return translateToolsToBackendImpl(tools);
}

/**
 * Translate prompts to backend CanvasModelContextPrompt format
 */
export function translatePromptsToBackend(
    prompts: ModelContextPrompt[]
): import('./modelContextTranslation-snapshot').BackendPromptDef[] {
    return translatePromptsToBackendImpl(prompts);
}

/**
 * Translate resources to backend CanvasModelContextResource format
 * 
 * Collects resources from context.resources array (supports both static and dynamic resources)
 */
export function translateResourcesToBackend(
    context: ModelContext
): import('./modelContextTranslation-snapshot').BackendResourceDef[] {
    return translateResourcesToBackendImpl(context);
}

// From: converters.ts
/**
 * Converters between SDK public API types and internal BotDojo types.
 *
 * SDK uses clean terminology:
 * - FlowRequestStep, onStepUpdate, subSteps, sessionId (camelCase)
 *
 * Internal uses existing terminology:
 * - FlowRequestIntermediateStep, onIntermediateStepUpdate, subIntermediateSteps, session_id (snake_case)
 */


// Import internal types from snapshot (avoids direct botdojo-core dependency)

/**
 * Convert internal FlowRequestIntermediateStep to SDK FlowRequestStep
 * Maps subIntermediateSteps → subSteps recursively
 * Parses arguments string into stepToolArguments and maps content to stepToolResult
 */
export function toSDKStep(internalStep: FlowRequestIntermediateStep): FlowRequestStep {
    const sdkStep: FlowRequestStep = {
        ...internalStep,
        subSteps: internalStep.subIntermediateSteps?.map(toSDKStep),
    };

    // Remove internal field
    delete (sdkStep as any).subIntermediateSteps;

    // Parse arguments string into stepToolArguments if not already set
    // Server sends `arguments` as a string, SDK expects `stepToolArguments` as an object
    if (!sdkStep.stepToolArguments && (internalStep as any).arguments) {
        const argsString = (internalStep as any).arguments;
        if (typeof argsString === 'string' && argsString.trim()) {
            try {
                sdkStep.stepToolArguments = JSON.parse(argsString);
            } catch {
                // Arguments may be partial/invalid JSON during streaming - ignore parse errors
            }
        }
    }

    // Map content to stepToolResult when tool is complete
    // Server sends result in `content`, SDK expects `stepToolResult`
    if (!sdkStep.stepToolResult && (internalStep as any).toolPhase === 'complete' && internalStep.content) {
        // Try to parse content as JSON if it looks like JSON
        const content = internalStep.content;
        if (content.trim().startsWith('{') || content.trim().startsWith('[')) {
            try {
                sdkStep.stepToolResult = JSON.parse(content);
            } catch {
                sdkStep.stepToolResult = content;
            }
        } else {
            sdkStep.stepToolResult = content;
        }
    }

    // Map toolPhase to stepToolPhase
    if ((internalStep as any).toolPhase) {
        sdkStep.stepToolPhase = (internalStep as any).toolPhase;
    }

    return sdkStep;
}

/**
 * Convert SDK FlowRequestStep to internal FlowRequestIntermediateStep
 * Maps subSteps → subIntermediateSteps recursively
 */
export function toInternalStep(sdkStep: FlowRequestStep): FlowRequestIntermediateStep {
    const internalStep: any = {
        ...sdkStep,
        subIntermediateSteps: sdkStep.subSteps?.map(toInternalStep),
    };

    // Remove SDK field
    delete internalStep.subSteps;

    return internalStep as FlowRequestIntermediateStep;
}

/**
 * Convert SDK callback options to internal callback format
 * Maps onStepUpdate → onIntermediateStepUpdate with automatic conversion
 */
export function toInternalCallbacks(sdkCallbacks?: IFlowCallbacks): InternalFlowCallbacks | undefined {
    if (!sdkCallbacks) return undefined;

    return {
        // SDK callbacks have different signatures than internal ones
        // For now, we only support the step update callback mapping
        onIntermediateStepUpdate: sdkCallbacks.onStepUpdate
            ? (step: FlowRequestIntermediateStep, trace: any) => {
                sdkCallbacks.onStepUpdate!(toSDKStep(step));
            }
            : undefined,
        // Note: Other SDK callbacks (onFlowRequestStart, onNewToken, etc.) are not currently mapped
        // as they have incompatible signatures with internal callbacks
    };
}

// Constant for converting dollars to billionths
const BILLIONTHS_OF_A_DOLLAR_MULTIPLIER = 1000000000;

/**
 * Convert SDK CircuitBreakerConfig (with Money in dollars) to API format (with cost in billionths)
 */
function convertCircuitBreakerToAPI(config?: any): any {
    if (!config) return undefined;
    
    const apiConfig: any = {};
    
    // Add timeout if present
    if (config.timeoutMs != null) {
        apiConfig.timeoutMs = config.timeoutMs;
    }
    
    // Convert Money (dollars) to API format (billionths)
    if (config.llmCostLimit) {
        apiConfig.llmCostLimitEnabled = true; // API still expects this flag
        apiConfig.llmCostLimit = {
            cost: Math.round(config.llmCostLimit.amount * BILLIONTHS_OF_A_DOLLAR_MULTIPLIER),
            unit: config.llmCostLimit.currency,
        };
    }
    
    return apiConfig;
}

/**
 * Convert SDK run options (camelCase) to internal format (snake_case)
 */
export function toInternalRunOptions(sdkOptions: any): any {
    if (!sdkOptions) return {};

    return {
        flow_id: sdkOptions.flowId,
        flow_session_id: sdkOptions.sessionId, // Map sessionId to flow_session_id for server
        stream_events: sdkOptions.streamEvents,
        stream: sdkOptions.stream,
        model_context: sdkOptions.modelContext,
        callbacks: toInternalCallbacks(sdkOptions.callbacks),
        debug: sdkOptions.debug,
        circuitBreaker: convertCircuitBreakerToAPI(sdkOptions.circuitBreaker),
    };
}

// From: toolResponseMapper.ts
/**
 * Content-only tool response mapper (MCP Apps)
 * Accepts ContentItem[] or plain values. Legacy actions/tool_response are not supported.
 */

type FlowCanvasType = 'file' | 'iframe' | 'code-interpreter' | 'dojo-canvas' | 'mcp-app';

export interface FlowCanvas {
  canvasType: FlowCanvasType;
  canvasData?: any;
}

export interface ToolResponseBackend {
  stepId?: string;
  stepLabel?: string;
  stepStatus?: string;
  canvas?: FlowCanvas;
  markdown?: string;
  markdownSummary?: string;
  outputFromTool: string;
  outputFromToolObject?: any;
  citations?: any[];
}

function isResourceContent(item: ContentItem): item is ContentItem & { resource: ResourceReference } {
  return item.type === 'resource' && !!item.resource;
}

function toCanvasFromResource(resource: ResourceReference): FlowCanvas | undefined {
  const mime = resource.mimeType || 'text/uri-list';
  const isMcp = mime === 'text/uri-list' || mime === 'text/html' || mime === 'text/html+mcp' || mime === 'text/html;profile=mcp-app';
  if (!isMcp) return undefined;

  const meta: any = resource.meta || {};
  const uiMeta = meta.ui || {};
  const frame = uiMeta.preferredFrameSize || {};
  const initialRenderData = uiMeta.initialRenderData;
  const stateless = uiMeta.stateless;
  const canvasData: any = {
    url: resource.text || resource.uri,
    mimeType: mime,
    show_inline: uiMeta.showInline ?? true,
    agent_enabled: true,
    width: frame?.[0] || frame?.width,
    height: frame?.[1] || frame?.height,
    ...(initialRenderData && { initialData: initialRenderData }),
    ...(uiMeta.displayName && { displayName: uiMeta.displayName }),
    ...(stateless !== undefined && { stateless }),
    metadata: resource.meta,
  };

  return {
    canvasType: 'mcp-app',
    canvasData,
  };
}

function processContentItems(items: ContentItem[]): ToolResponseBackend {
  const outputFromToolObject = items;
  const outputFromTool = JSON.stringify(items, null, 2);

  // Pick first UI resource as canvas
  let canvas: FlowCanvas | undefined;
  for (const item of items) {
    if (isResourceContent(item)) {
      const maybe = toCanvasFromResource(item.resource);
      if (maybe) {
        canvas = maybe;
        break;
      }
    }
  }

  return {
    outputFromTool,
    outputFromToolObject,
    canvas,
  };
}

/**
 * Map tool return value to backend-compatible response.
 */
export async function mapToolResponseToBackend<TResult = any>(response: ContentItem[] | TResult): Promise<ToolResponseBackend> {
  if (Array.isArray(response)) {
    return processContentItems(response as ContentItem[]);
  }

  // Plain object/string/number result
  return {
    outputFromTool: response === undefined ? '' : JSON.stringify(response, null, 2),
    outputFromToolObject: response,
  };
}

// From: type-mappers.ts
/**
 * Type Mappers between SDK types and Backend types
 * 
 * These mappers provide compile-time validation that SDK types remain
 * compatible with backend types for Flow-related operations.
 * 
 * Note: Model context types are NOT validated here because SDK uses
 * a translation utility (type-translation.ts) to convert from SDK format
 * to backend format. This allows SDK and backend to have different shapes.
 * 
 * Imports from backend-types-snapshot.ts (generated by sync-backend-types.js)
 * This avoids a package dependency cycle while still enabling type validation.
 */


/**
 * Validate Flow-related types for compatibility
 */

// FlowRequestRecord compatibility - verify key fields exist
type _FlowRequestRecordHasId = Backend.Core_FlowRequestRecord extends { id?: string } ? true : 'FlowRequestRecord missing id';
type _FlowRequestRecordHasFlowId = Backend.Core_FlowRequestRecord extends { flow_id?: string } ? true : 'FlowRequestRecord missing flow_id';

// FlowRequestParams compatibility - verify key fields exist  
type _FlowRequestParamsHasFlowId = Backend.Core_FlowRequestParams extends { flow_id?: any } ? true : 'FlowRequestParams missing flow_id';
type _FlowRequestParamsHasStream = Backend.Core_FlowRequestParams extends { stream?: any } ? true : 'FlowRequestParams missing stream';

// Validate that all checks pass
type _AllChecksPass = [
    _FlowRequestRecordHasId,
    _FlowRequestRecordHasFlowId,
    _FlowRequestParamsHasFlowId,
    _FlowRequestParamsHasStream
] extends [true, true, true, true] ? true : never;

// This will cause a compile error if any validation fails
// Temporarily commented out - backend types not built yet
// const _typeValidation: _AllChecksPass = true;

/**
 * Export a simple validation that the types can be used interchangeably
 * where it matters for the SDK API surface.
 */
export function validateTypes(): void {
    // This function exists only for type checking
    // It will fail to compile if types become incompatible
}

// From: backend-types-snapshot.ts
/**
 * Backend Types Snapshot (STUB - backend types not available)
 * 
 * This file is auto-generated by scripts/sync-backend-types.js
 * To generate real types: pnpm --filter botdojo-sdk-backend-types build
 */

// Stub types - backend-types not built yet
// Note: Model context types excluded - SDK handles translation
export type Core_FlowData = any;
export type Core_FlowRequestParams = any;
export type Core_FlowRequestRecord = any;
export type Core_IFlowCallbacks = any;
export type Core_FlowCanvas = any;
export type Core_IChatSidePanel = any;
export type Core_Citation = any;
export type Core_ToolExecutionPhase = any;
export type Core_TokenUpdate = any;

// Types needed by converters.ts
export type Core_FlowRequestIntermediateStep = any;
export type Core_InternalFlowCallbacks = any;

// ============================================================================
// Main exports from sdk-types/index.ts
// ============================================================================

export interface ResourceReference {
    /** Resource URI (e.g., 'ui://product/123', 'mcp://actions') */
    uri: string;
    /** MIME type determines how resource is processed */
    mimeType?: string;
    /** Resource content (URL for uri-list, inline HTML for text/html(+mcp), or URI for modelcontext) */
    text?: string;
    /** Inline HTML for `text/html`, `text/html+mcp`, or `text/html;profile=mcp-app` resources */
    html?: string;
    /** Optional allowlist for URL-based resources (matches SEP url-list direction) */
    urlList?: string[];
    /** Base URL to apply to inline HTML (used for relative asset resolution) */
    baseUrl?: string;
    /** Hint to prefer sandbox proxy even when a URL exists */
    prefersProxy?: boolean;
    /** Hint to allow direct external URL rendering even when inline HTML is present */
    allowExternal?: boolean;
    /** Metadata for UI resources only */
    meta?: {
        /** SEP-1865 UI metadata */
        ui?: {
            /** Preferred iframe dimensions (object or tuple) */
            preferredFrameSize?: { width: string; height: string } | [string, string];
            /** Initial render data/state */
            initialRenderData?: any;
            /** Optional display name for the canvas */
            displayName?: string;
            /** If true, canvas should not be persisted */
            stateless?: boolean;
            /** MIME type hint for the UI resource */
            mimeType?: string;
            /** Optional CSP hints */
            csp?: {
                connectDomains?: string[];
                resourceDomains?: string[];
                domain?: string;
                allowPopups?: boolean;
                allowForms?: boolean;
                allowSameOrigin?: boolean;
                prefersBorder?: boolean;
            };
            /** Optional resource hints for inline/URL handling */
            urlList?: string[];
            baseUrl?: string;
            prefersProxy?: boolean;
            allowExternal?: boolean;
        };
        /** Additional metadata */
        [key: string]: any;
    };
}

/**
 * MCP-compliant content item for tool results
 * 
 * Tools should return ContentItem[] for rich responses, or plain objects for simple results.
 * 
 * @example
 * ```typescript
 * // Simple text response
 * return [{ type: 'text', text: 'Operation successful' }];
 * 
 * // UI resource with initial data
 * return [
 *   { type: 'text', text: 'Product loaded' },
 *   { 
 *     type: 'resource',
 *     resource: {
 *       uri: 'ui://product/123',
 *       mimeType: 'text/uri-list',
 *       meta: { ui: { initialRenderData: { product } } }
 *     }
 *   }
 * ];
 * ```
 */
export interface ContentItem {
    /** Content type: text, image, or resource */
    type: 'text' | 'image' | 'resource';
    /** Text content (for type: 'text') */
    text?: string;
    /** Base64-encoded image data (for type: 'image') */
    data?: string;
    /** MIME type for images (e.g., 'image/png') */
    mimeType?: string;
    /** Resource reference (for type: 'resource') */
    resource?: ResourceReference;
}

/**
 * Citation data for referencing sources
 * Citations are BotDojo primitives, not UI resources
 */
export interface CitationData {
    /** Required unique identifier */
    id: string;
    /** Source name/title */
    source: string;
    /** Optional URL */
    url?: string;
    /** Optional quote/excerpt */
    text?: string;
    /** Additional metadata */
    [key: string]: any;
}

/**
 * Tool execution result type
 * Tools can return:
 * - ContentItem[] for rich responses (UI, citations, etc.)
 * - Plain object/primitive for simple results
 */
export type ToolExecutionResult<TResult = any> = ContentItem[] | TResult;

// ============================================================================
// MIME Type Constants
// ============================================================================

/**
 * Standard MIME types for BotDojo resources
 */
export const MIME_TYPES = {
    // UI Canvas types (MCP Apps standard)
    URI_LIST: 'text/uri-list',
    HTML: 'text/html',
    HTML_MCP: 'text/html+mcp',
    HTML_MCP_PROFILE: 'text/html;profile=mcp-app',
    // Remote DOM (both MCP Apps standard and BotDojo alias)
    REMOTE_DOM: 'application/vnd.mcp-ui.remote-dom',
    REMOTE_DOM_BOTDOJO: 'application/vnd.botdojo.ui-remote-dom',
    // BotDojo extensions
    MODEL_CONTEXT: 'application/vnd.botdojo.modelcontext',
    CITATION: 'application/vnd.botdojo.citation',
    CITATIONS: 'application/vnd.botdojo.citations',
} as const;

export const MCP_HTML_MIME_TYPES = [
    MIME_TYPES.HTML_MCP,
    MIME_TYPES.HTML_MCP_PROFILE,
] as const;

/**
 * Context provided to tools during execution
 * Includes methods for updating canvas state in real-time.
 *
 * MCP App canvases receive `hostContext.toolInfo` with the tool schema.
 * Tool arguments/results come via ui/notifications/tool-input and tool-result.
 * `hostContext.state` hydrates from UI state persistence (BotDojo extension);
 * use `updateState` strictly for UI state (e.g., counters).
 */
export interface ToolExecutionContext {
    /** Name of the tool being executed (helpful for logging/notifications) */
    toolName?: string;
    /**
     * Update canvas UI state during tool execution (if resource-template is present).
     * Do not mirror tool arguments/results here; the host caches that from
     * `ui/notifications/tool-*`. Keep this for UI persistence only.
     */
    updateState?: (state: any) => Promise<void>;
    /**
     * Send MCP Apps tool notifications to the UI host (SEP-1865).
     * Implementations should emit JSON-RPC notifications using context.toolName:
     *  - ui/notifications/tool-input-partial (streaming args)
     *  - ui/notifications/tool-input (final args)
     *  - ui/notifications/tool-result (result payload)
     */
    notifyToolInputPartial?: (args: Record<string, unknown>) => Promise<void>;
    notifyToolInput?: (args: Record<string, unknown>) => Promise<void>;
    notifyToolResult?: (result: any) => Promise<void>;
}

/**
 * Tool metadata following MCP Apps SDK pattern
 * Uses _meta with vendor-namespaced extensions (kebab-case)
 * 
 * All BotDojo-specific options use 'botdojo/' prefix with kebab-case keys
 */
export interface ToolMetadata {
    // SEP-1865 UI metadata (preferred over legacy mcpui.dev/*)
    ui?: {
        preferredFrameSize?: { width: string; height: string } | [string, string];
        initialRenderData?: any;
        displayName?: string;
        stateless?: boolean;
        /** Resource URI for pre-rendering during streaming */
        resourceUri?: string;
        mimeType?: 'text/html+mcp' | 'text/html;profile=mcp-app' | 'text/html' | 'text/uri-list';
        showInline?: boolean;
        agentEnabled?: boolean;
        /** Optional render hints for inline/URL MCP Apps */
        urlList?: string[];
        baseUrl?: string;
        prefersProxy?: boolean;
        allowExternal?: boolean;
    };

    // BotDojo resource template for pre-rendering during argument streaming
    'botdojo/resource-template'?: {
        uri: string;         // Resource URI (e.g., 'ui://dashboard/main')
        mimeType: string;    // MIME type: 'text/uri-list' | 'text/html' | 'text/html+mcp' | 'text/html;profile=mcp-app' | 'application/vnd.botdojo.ui-remote-dom'
        metadata?: {
            ui?: {
                preferredFrameSize?: { width: string; height: string } | [string, string];
                initialRenderData?: any;
                displayName?: string;
                stateless?: boolean;
                mimeType?: string;
            };
            [key: string]: any;
        };
    };

    // BotDojo display hints (kebab-case to match MCP Apps standard)
    'botdojo/display-name'?: string;       // Display name for the tool step
    'botdojo/hide-step'?: boolean;         // Hide entire step in UI
    'botdojo/hide-step-details'?: boolean; // Hide step details (show label only)
}

/**
 * Tool definition for defining tools
 * Can be used in two ways:
 * 1. In an array: tools: ToolDefinition[] (needs 'name' field)
 * 2. In an object: tools: Record<string, ToolDefinition> ('name' is the key, so field is optional)
 * 
 * Display hints (displayName, hideStep, hideStepDetails) are in _meta with botdojo/ prefix
 */
export interface ToolDefinition<TParams = any, TResult = any> {
    name?: string;
    description: string;
    /** JSON Schema for parameters (MCP standard) */
    inputSchema?: any;
    /** Tool metadata - display hints and resource templates */
    _meta?: ToolMetadata;
    /** Execute function - returns ContentItem[] or plain result */
    /** Can accept optional ToolExecutionContext as second parameter for notifications */
    execute?: (params: TParams, context?: ToolExecutionContext) => Promise<ToolExecutionResult<TResult>>;
}

export interface ModelContextMessage {
    role: string;
    content: string;
}

export interface ModelContextPrompt {
    name: string;
    description: string;
    messages: ModelContextMessage[];
}

/**
 * Resource template for dynamic resource discovery
 * Compatible with IResourceProvider pattern in botdojo-core
 */
export interface ResourceTemplate {
    /** URI template following RFC 6570 (e.g., "myapp://users/{userId}") */
    uriTemplate: string;
    /** Unique identifier for this template */
    name: string;
    /** Human-readable name */
    label: string;
    /** Description of this resource type */
    description?: string;
    /** MIME type for resources matching this template */
    mimeType?: string;
    /** Additional metadata */
    meta?: {
        title?: string;
        description?: string;
        icon?: string;
        defaultToolPrefix?: string;
        [key: string]: any;
    };
}

/**
 * Resource provider for dynamic resource discovery
 * Compatible with Resource Manager MCP v2
 */
export interface ResourceProvider {
    /** Unique provider ID */
    id: string;
    /** Resource templates this provider supports */
    templates: ResourceTemplate[];
    /**
     * Get a resource by URI
     * @param templateName The name of the template that matched
     * @param uri The resource URI to fetch
     * @param params Extracted template parameters
     * @param onlyMetadata If true, only return metadata (no content)
     */
    getResource: (templateName: string, uri: string, params: any, onlyMetadata?: boolean) => Promise<ResourceContent>;
}

/**
 * Resource content returned by a provider
 */
export interface ResourceContent {
    uri: string;
    mimeType?: string;
    text?: string;
    meta?: {
        title?: string;
        description?: string;
        [key: string]: any;
    };
    links?: Array<{
        uri: string;
        rel: string;
        description?: string;
    }>;
    /** If this resource is itself an MCP, include it here */
    mcp?: ModelContext[];
}

/**
 * Static resource with fixed URI
 * 
 * @example
 * ```typescript
 * {
 *   uri: 'myapp://help',
 *   mimeType: 'text/markdown',
 *   getContent: async () => '# Help...'
 * }
 * ```
 */
export interface ModelContextStaticResource {
    /** Fixed URI for this resource */
    uri: string;
    /** Resource name (optional - can be inferred from uri) */
    name?: string;
    /** Human-readable label */
    label?: string;
    /** MIME type of the resource */
    mimeType?: string;
    /** Description of the resource */
    description?: string;
    /** Additional metadata */
    meta?: {
        title?: string;
        description?: string;
        icon?: string;
        [key: string]: any;
    };
    /** Get resource content (no parameters for static resources) */
    getContent: () => Promise<string | { url: string } | ResourceContent>;
}

/**
 * Dynamic resource with parameterized URI template
 * 
 * @example
 * ```typescript
 * {
 *   uriTemplate: 'myapp://file/{filepath}',
 *   mimeType: 'botdojo/mcp',
 *   getContent: async (params) => {
 *     // params.filepath is extracted from URI
 *     return { mcp: [...] }
 *   }
 * }
 * ```
 */
export interface ModelContextDynamicResource {
    /** URI template with parameters - e.g., "myapp://users/{userId}" */
    uriTemplate: string;
    /** Resource name (optional - can be inferred from template) */
    name?: string;
    /** Human-readable label */
    label?: string;
    /** MIME type of the resource */
    mimeType?: string;
    /** Description of the resource */
    description?: string;
    /** Additional metadata */
    meta?: {
        title?: string;
        description?: string;
        icon?: string;
        [key: string]: any;
    };
    /** Get resource content with extracted parameters */
    getContent: (params: Record<string, any>) => Promise<string | { url: string } | ResourceContent>;
}

/**
 * Model context resource - can be either static or dynamic
 */
export type ModelContextResource = ModelContextStaticResource | ModelContextDynamicResource;

/**
 * CORS configuration for iframe PostMessage security
 * Used internally by the system (backend, canvas host)
 */
export interface CorsConfig {
    /**
     * Trusted BotDojo chat iframe domains
     * Used by parent and canvas to validate PostMessage SOURCE
     * Configured server-side via flow chat settings
     * 
     * **Backward Compatible Default:** If undefined, ALL origins are trusted
     * (same as pre-CORS behavior). This ensures existing embed chat users
     * don't experience breaking changes.
     * 
     * **If defined:** ENFORCED - only PostMessages from these domains accepted
     * 
     * Examples:
     * - Standard: ["https://embed.botdojo.com"]
     * - Self-hosted: ["https://chat.mycompany.com"]
     * - Multi-env: ["https://embed.botdojo.com", "https://staging-chat.mycompany.com"]
     */
    botdojoChatDomain?: string[];
    
    /**
     * Allowed origins for tool call routing
     * Used by chat iframe router and backend to validate which origins can call tools
     * These are user application domains that can call tools
     * Example: ["https://myshop.com", "https://admin.myshop.com"]
     * Default: same-origin only
     */
    allowedToolCallOrigins?: string[];
}

/**
 * MCP-level CORS configuration for tool call security
 * Configured by developers when defining MCP backends
 *
 * IMPORTANT: Only validates parent/canvas → chat tool calls.
 * Agent → parent/canvas tool calls use origin='server' and bypass validation.
 */
export interface ModelContextCorsConfig {
    /**
     * Origins allowed to call tools on this MCP backend
     * Used by chat iframe router to validate tool call origins FROM parent/canvas
     *
     * Default: undefined = ALL origins allowed (permissive by default)
     * Empty array [] = NO origins allowed (block all)
     * 'server' = Reserved, always allowed (agent tool calls)
     *
     * Protocol enforcement: Must match exactly (https:// ≠ http://)
     * Port enforcement: Must match exactly (:443 ≠ :80)
     * Wildcard support: Prefix only, follows CORS spec (*.myshop.com matches any subdomain)
     *
     * Examples:
     * - undefined → Allow all (backward compatible)
     * - [] → Block all parent/canvas tool calls
     * - ["https://myshop.com", "https://admin.myshop.com"] → Exact matches only
     * - ["*.myshop.com"] → Allow any subdomain (app.myshop.com, admin.myshop.com)
     * - ["https://myshop.com"] → Does NOT match http://myshop.com (protocol differs)
     */
    allowedToolCallOrigins?: string[];
}

/**
 * SDK-specific CORS configuration for tool calls
 * Used by BotDojoChatProps and BotDojoConnector constructor
 *
 * Note: botdojoChatDomain is NOT included here because it's configured
 * server-side in flow chat settings, not by SDK users.
 *
 * @example
 * ```tsx
 * <BotDojoChat
 *   apiKey="..."
 *   cors={{ allowedToolCallOrigins: ['https://myapp.com'] }}
 * />
 * ```
 */
export interface ToolCallCorsConfig {
    /**
     * Allowed origins that can call tools from this parent page
     * Used by chat iframe to validate tool call routing
     *
     * Examples:
     * - ["https://myapp.com"] - Only myapp.com can call tools
     * - ["https://myapp.com", "https://admin.myapp.com"] - Multiple domains
     * - undefined - Default (same-origin only)
     */
    allowedToolCallOrigins?: string[];
}

/**
 * Model context definition with tools, prompts, and resources
 * Tools can be defined as either:
 * - An array: tools: ToolDefinition[] (each tool needs 'name' field)
 * - An object: tools: Record<string, ToolDefinition> (key is the tool name)
 * 
 * Resources support both static and dynamic patterns:
 * - Static: { uri: 'app://help', getContent: async () => '...' }
 * - Dynamic: { uriTemplate: 'app://file/{id}', getContent: async (params) => '...' }
 */
export interface ModelContext {
    name: string;
    description?: string;
    toolPrefix?: string;
    /** Unique URI identifier for this model context */
    uri?: string;

    tools?: ToolDefinition[] | Record<string, ToolDefinition>;
    prompts?: ModelContextPrompt[];
    /** Unified resources array supporting both static and dynamic resources */
    resources?: ModelContextResource[];
    /**
     * CORS configuration for this MCP
     *
     * **Backend Use**: Server enforces these rules before executing tools
     * - allowedToolCallOrigins: Which parent/canvas origins can call tools from this MCP
     *
     * **Note**: For SDK usage (BotDojoChat/BotDojoConnector), use the
     * constructor-level `cors` parameter with ToolCallCorsConfig instead.
     * This field is primarily for backend per-MCP enforcement.
     */
    cors?: ModelContextCorsConfig;
}

/**
 * Tool handler function type
 */
export type ConnectorToolCalls = Record<string, (...args: any[]) => Promise<any>>;

// ============================================================================
// SECTION 2: Flow Request & Callback Types
// ============================================================================

export interface IFlowCallbacks {
    onNewToken?: (token: string) => void;
    onStepUpdate?: (step: FlowRequestStep) => void; // ← RENAMED from onIntermediateStepUpdate
    onLog?: (trace: ITrace) => void;
    onFlowRequestStart?: (flowRequest: FlowRequestRecord) => void;
    onFlowRequestEnd?: (flowRequest: FlowRequestRecord) => void;
    [key: string]: any;
}

/**
 * SDK version of flow request step with clean terminology
 * Maps to internal FlowRequestIntermediateStep but uses cleaner field names
 */
export interface FlowRequestStep {
    stepId: string;
    stepLabel: string;
    stepStatus: 'complete' | 'error' | 'processing';
    error?: string;
    content: string;
    startTime: Date;
    canvas?: Core_FlowCanvas;
    parentStepId?: string;
    subSteps?: FlowRequestStep[];  // ← RENAMED from subIntermediateSteps
    // Tool execution properties
    stepToolName?: string;
    stepToolArguments?: Record<string, any>;
    stepToolResult?: any;
    stepToolPhase?: Core_ToolExecutionPhase;
}

export interface ITrace {
    message: string;
    level: string;
    timestamp: string;
    [key: string]: any;
}

/**
 * Money amount in US dollars
 */
export interface Money {
    /** Amount in US dollars (e.g., 0.01 = 1 cent, 1.50 = $1.50) */
    amount: number;
    /** Currency code (currently only USD is supported) */
    currency: 'USD';
}

/**
 * Circuit breaker configuration for flow execution
 * If a property is populated, that circuit breaker is enabled
 */
export interface CircuitBreakerConfig {
    /** Timeout in milliseconds. If set, timeout circuit breaker is enabled */
    timeoutMs?: number;
    /** LLM cost limit in US dollars. If set, cost limit circuit breaker is enabled (e.g., { amount: 0.01, currency: 'USD' } = 1 cent) */
    llmCostLimit?: Money;
}

export type StreamEventType = 'onNewToken' | 'onIntermediateStepUpdate' | 'onLog' | 'onFlowRequestStart' | 'onFlowRequestEnd';
export interface FlowRequestOptions {
    flowId?: string;
    stream_events?: StreamEventType[] | boolean;
    session_id?: string;
    debug?: boolean;
    modelContext?: ModelContext | ModelContext[];
    callbacks?: IFlowCallbacks;
    circuitBreaker?: CircuitBreakerConfig;
}

export interface FlowRequestParams {
    id?: string;
    flow_id: string;
    account_id: string;
    project_id: string;
    input?: any;
    stream?: 'http' | 'job' | 'realtime' | 'none';
    stream_events?: string[];
    session_id?: string;
    debug?: boolean;
    external_ui_channel_id?: string;
    circuitBreaker?: CircuitBreakerConfig;
    [key: string]: any;
}

export interface ChatMessage {
    id?: string;
    role: 'user' | 'assistant' | 'system';
    content: string;
    timestamp?: Date | string;
    attachments?: any[];
    citations?: any[];
    [key: string]: any;
}

export interface FlowRequestRecord {
    id: string;
    flow_id: string;
    account_id: string;
    project_id: string;
    status: 'pending' | 'running' | 'complete' | 'error';
    input?: any;
    output?: any;
    error?: string;
    job_id?: string;
    created_at?: string;
    updated_at?: string;
    userMessage?: ChatMessage;
    aiMessage?: ChatMessage;
    [key: string]: any;
}

export interface FlowData {
    id: string;
    name: string;
    account_id: string;
    project_id: string;
    nodes?: any[];
    edges?: any[];
    [key: string]: any;
}

/**
 * Flow information record (SDK type)
 * Represents a flow without the full flow definition
 */
export interface FlowInfo {
    id: string;
    name: string;
    description?: string;
    account_id: string;
    project_id: string;
    created?: Date | string;
    updated?: Date | string;
    folderPath?: string;
    isPublic?: boolean;
    flowType?: string;
    [key: string]: any;
}

// Aliases for consistency (used by canvas-client)
export type FlowRequestBody = Record<string, any>;
export type FlowResponse = FlowRequestRecord;

// Re-export supporting types for convenience

// ADD: FlowRequest alias - simpler, cleaner name
export type FlowRequest = FlowRequestRecord;

// ============================================================================
// SECTION 3: Client Configuration & Interface (SDK-specific)
// ============================================================================

export interface BotDojoClientConfig {
    apiKey: string;
    apiUrl?: string;
    socketIoUrl?: string; // Separate URL for Socket.IO/RPC connections (defaults to apiUrl if not provided)
    debug?: boolean;
    accountId?: string;
    projectId?: string;
}

export interface IBotDojoClient {
    runFlow(input: any, options?: Partial<FlowRequestOptions>): Promise<FlowRequestRecord>;
    getFlowRequest(id: string): Promise<FlowRequestRecord>;
    getSessionFlowRequests(flowId: string, sessionId: string): Promise<FlowRequestRecord[]>;
    
    // Namespaces
    readonly Flows: {
        get(id: string): Promise<FlowData>;
        list(options?: { sessionId?: string; flowId?: string }): Promise<FlowInfo[] | FlowRequestRecord[]>;
    };
    readonly FlowRequest: {
        get(id: string): Promise<FlowRequestRecord>;
        getSession(flowId: string, sessionId: string): Promise<FlowRequestRecord[]>;
    };
}

// ============================================================================
// SECTION 4: RPC Client Configuration
// (Note: "Canvas" in config names refers to the botdojo-canvas-client package,
//  which handles RPC connections - this is acceptable legacy naming)
// ============================================================================

export interface BotDojoCanvasClientConfig {
    url: string;
    channel: string;
    senderId: string;
    receiverId: string;
}

// ============================================================================
// SECTION 5: RPC & Utility Types
// ============================================================================

export interface AbortHandler {
    onAbort?: () => void;
}

export interface BaseRecord<T> {
    id: string;
    account_id?: string;
    project_id?: string;
    created_at?: string;
    updated_at?: string;
    [key: string]: any;
}

export type FlowRequestStreamType = 'http' | 'realtime' | 'job' | 'none';

// ============================================================================
// SECTION 6: Tool & Resource Utilities
// ============================================================================

// Tool utilities

export type {
    SDKToolDefinition,
    ToolsRecord,
    ToolHandler,
    JSONSchema,
    ZodSchema,
    ModelContextDefinition
} from './tool-utils';

// Resource utilities

export type {
    ResourceContentResult,
    ResourceContentObject
} from './resource-utils';

// Type translation utilities

export type {
    BackendModelContext,
    BackendToolDef,
    BackendPromptDef,
    BackendResourceDef
} from './type-translation';

// Converters between SDK and internal types

// MCP Apps (SEP-1865) vendored types


// ============================================================================
// Exports for @botdojo/chat-sdk
// ============================================================================

